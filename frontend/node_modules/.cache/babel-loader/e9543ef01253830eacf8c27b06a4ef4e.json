{"ast":null,"code":"import { createMemoryHistory, parsePath } from 'history';\nimport PropTypes from 'prop-types';\nimport { createContext, useRef, createElement, useContext, useEffect, useState, useMemo, useCallback, Children, isValidElement, Fragment, useTransition as useTransition$1 } from 'react';\n\nfunction h() {\n  h = Object.assign || function (a) {\n    for (var b = 1; b < arguments.length; b++) {\n      var c = arguments[b],\n          d;\n\n      for (d in c) Object.prototype.hasOwnProperty.call(c, d) && (a[d] = c[d]);\n    }\n\n    return a;\n  };\n\n  return h.apply(this, arguments);\n}\n\nvar k = \"production\" !== process.env.NODE_ENV ? function (a) {\n  return Object.freeze(a);\n} : function (a) {\n  return a;\n};\n\nfunction l(a, b) {\n  if (!a) throw Error(b);\n}\n\nfunction m(a, b) {\n  if (!a) {\n    \"undefined\" !== typeof console && console.warn(b);\n\n    try {\n      throw Error(b);\n    } catch (c) {}\n  }\n}\n\nvar p = createContext({\n  history: null,\n  location: null,\n  pending: !1,\n  static: !1\n});\n\"production\" !== process.env.NODE_ENV && (p.displayName = \"Location\");\nvar q = createContext({\n  outlet: null,\n  params: k({}),\n  pathname: \"\",\n  route: null\n});\n\"production\" !== process.env.NODE_ENV && (q.displayName = \"Route\");\n\nfunction t(a) {\n  var b = a.children,\n      c = a.initialEntries,\n      d = a.initialIndex;\n  a = a.timeout;\n  var e = useRef(null);\n  null == e.current && (e.current = createMemoryHistory({\n    initialEntries: c,\n    initialIndex: d\n  }));\n  return createElement(v, {\n    children: b,\n    history: e.current,\n    timeout: a\n  });\n}\n\n\"production\" !== process.env.NODE_ENV && (t.displayName = \"MemoryRouter\", t.propTypes = {\n  children: PropTypes.node,\n  timeout: PropTypes.number,\n  initialEntries: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.shape({\n    pathname: PropTypes.string,\n    search: PropTypes.string,\n    hash: PropTypes.string,\n    state: PropTypes.object,\n    key: PropTypes.string\n  })])),\n  initialIndex: PropTypes.number\n});\n\nfunction w(a) {\n  var b = a.to,\n      c = a.replace,\n      d = a.state;\n  y() ? void 0 : \"production\" !== process.env.NODE_ENV ? l(!1, \"<Navigate> may be used only in the context of a <Router> component.\") : l(!1);\n  a = useContext(p);\n  \"production\" !== process.env.NODE_ENV ? m(!a.static, \"<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.\") : void 0;\n  var e = z();\n  useEffect(function () {\n    e(b, {\n      replace: c,\n      state: d\n    });\n  });\n  return null;\n}\n\n\"production\" !== process.env.NODE_ENV && (w.displayName = \"Navigate\", w.propTypes = {\n  to: PropTypes.oneOfType([PropTypes.string, PropTypes.shape({\n    pathname: PropTypes.string,\n    search: PropTypes.string,\n    hash: PropTypes.string\n  })]).isRequired,\n  replace: PropTypes.bool,\n  state: PropTypes.object\n});\n\nfunction A() {\n  return B();\n}\n\n\"production\" !== process.env.NODE_ENV && (A.displayName = \"Outlet\", A.propTypes = {});\n\nfunction C(a) {\n  a = a.element;\n  return void 0 === a ? createElement(A, null) : a;\n}\n\n\"production\" !== process.env.NODE_ENV && (C.displayName = \"Route\", C.propTypes = {\n  children: PropTypes.node,\n  element: PropTypes.element,\n  path: PropTypes.string\n});\n\nfunction D(a) {\n  return a();\n}\n\nvar E = useTransition$1 || function () {\n  return [D, !1];\n};\n\nfunction v(a) {\n  var b = a.children;\n  b = void 0 === b ? null : b;\n  var c = a.history,\n      d = a.static;\n  d = void 0 === d ? !1 : d;\n  a = a.timeout;\n  var e = void 0 === a ? 2E3 : a;\n  y() ? \"production\" !== process.env.NODE_ENV ? l(!1, \"You cannot render a <Router> inside another <Router>. You never need more than one.\") : l(!1) : void 0;\n  var f = useState(c.location);\n  a = f[0];\n  var g = f[1];\n  e = E({\n    timeoutMs: e\n  });\n  var x = e[0];\n  e = e[1];\n  f = useRef(!d);\n  f.current && (f.current = !1, c.listen(function (a) {\n    var c = a.location;\n    x(function () {\n      g(c);\n    });\n  }));\n  return createElement(p.Provider, {\n    children: b,\n    value: {\n      history: c,\n      location: a,\n      pending: e,\n      static: d\n    }\n  });\n}\n\n\"production\" !== process.env.NODE_ENV && (v.displayName = \"Router\", v.propTypes = {\n  children: PropTypes.node,\n  history: PropTypes.shape({\n    action: PropTypes.string,\n    location: PropTypes.object,\n    push: PropTypes.func,\n    replace: PropTypes.func,\n    go: PropTypes.func,\n    listen: PropTypes.func,\n    block: PropTypes.func\n  }),\n  timeout: PropTypes.number\n});\n\nfunction F(a) {\n  var b = a.basename;\n  b = void 0 === b ? \"\" : b;\n  a = G(a.children);\n  return H(a, b);\n}\n\n\"production\" !== process.env.NODE_ENV && (F.displayName = \"Routes\", F.propTypes = {\n  basename: PropTypes.string,\n  caseSensitive: PropTypes.bool,\n  children: PropTypes.node\n});\n\nfunction y() {\n  return null != useContext(p).location;\n}\n\nfunction I() {\n  y() ? void 0 : \"production\" !== process.env.NODE_ENV ? l(!1, \"useLocation() may be used only in the context of a <Router> component.\") : l(!1);\n  return useContext(p).location;\n}\n\nfunction z() {\n  y() ? void 0 : \"production\" !== process.env.NODE_ENV ? l(!1, \"useNavigate() may be used only in the context of a <Router> component.\") : l(!1);\n  var a = useContext(p),\n      b = a.history,\n      c = a.pending,\n      d = useContext(q).pathname,\n      e = useRef(!1);\n  useEffect(function () {\n    e.current = !0;\n  });\n  return useCallback(function (a, g) {\n    void 0 === g && (g = {});\n    e.current ? \"number\" === typeof a ? b.go(a) : (a = J(a, d), (g.replace || c ? b.replace : b.push)(a, g.state)) : \"production\" !== process.env.NODE_ENV ? m(!1, \"You should call navigate() in a useEffect, not when your component is first rendered.\") : void 0;\n  }, [b, d, c]);\n}\n\nfunction B() {\n  return useContext(q).outlet;\n}\n\nfunction K(a) {\n  var b = useContext(q).pathname;\n  return useMemo(function () {\n    return J(a, b);\n  }, [a, b]);\n}\n\nvar L = {};\n\nfunction M(a, b, c) {\n  b || L[a] || (L[a] = !0, \"production\" !== process.env.NODE_ENV ? m(!1, c) : void 0);\n}\n\nfunction H(a, b) {\n  void 0 === b && (b = \"\");\n  var c = useContext(q),\n      d = c.route,\n      e = c.pathname,\n      f = c.params;\n  \"production\" !== process.env.NODE_ENV && (c = d && d.path, M(e, !d || d.path.endsWith(\"*\"), 'You rendered descendant <Routes> (or called `useRoutes`) at \"' + e + '\" (under <Route path=\"' + (c + '\">) but the parent route path has no trailing \"*\". This means if you navigate deeper, the parent won\\'t match anymore and therefore the child routes will never render.\\n\\nPlease change the parent <Route path=\"') + (c + '\"> to <Route path=\"' + c + '/*\">.')));\n  b = b ? N([e, b]) : e;\n  var g = I();\n  return (d = useMemo(function () {\n    return O(a, g, b);\n  }, [g, a, b])) ? d.reduceRight(function (a, c) {\n    var d = c.pathname,\n        e = c.route;\n    return createElement(q.Provider, {\n      children: e.element,\n      value: {\n        outlet: a,\n        params: k(h({}, f, {}, c.params)),\n        pathname: N([b, d]),\n        route: e\n      }\n    });\n  }, null) : null;\n}\n\nfunction P(a) {\n  return a.map(function (a) {\n    var c = {\n      caseSensitive: !0 === a.caseSensitive,\n      element: a.element || createElement(A, null),\n      path: a.path || \"/\"\n    };\n    a.children && (c.children = P(a.children));\n    return c;\n  });\n}\n\nfunction G(a) {\n  var b = [];\n  Children.forEach(a, function (a) {\n    if (isValidElement(a)) if (a.type === Fragment) b.push.apply(b, G(a.props.children));else {\n      var c = {\n        caseSensitive: !0 === a.props.caseSensitive,\n        element: a,\n        path: a.props.path || \"/\"\n      };\n      a.props.children && (a = G(a.props.children), a.length && (c.children = a));\n      b.push(c);\n    }\n  });\n  return b;\n}\n\nfunction O(a, b, c) {\n  void 0 === c && (c = \"\");\n  \"string\" === typeof b && (b = parsePath(b));\n  b = b.pathname || \"/\";\n  if (c) if (c = c.replace(/^\\/*/, \"/\").replace(/\\/+$/, \"\"), b.startsWith(c)) b = b === c ? \"/\" : b.slice(c.length);else return null;\n  a = Q(a);\n  R(a);\n  var d = null;\n\n  for (c = 0; null == d && c < a.length; ++c) a: {\n    d = b;\n\n    for (var e = a[c][1], f = \"/\", g = {}, x = [], n = 0; n < e.length; ++n) {\n      var r = e[n],\n          u = \"/\" === f ? d : d.slice(f.length) || \"/\";\n      u = S({\n        path: r.path,\n        caseSensitive: r.caseSensitive,\n        end: n === e.length - 1\n      }, u);\n\n      if (!u) {\n        d = null;\n        break a;\n      }\n\n      f = N([f, u.pathname]);\n      g = h({}, g, {}, u.params);\n      x.push({\n        route: r,\n        pathname: f,\n        params: k(g)\n      });\n    }\n\n    d = x;\n  }\n\n  return d;\n}\n\nfunction Q(a, b, c, d, e) {\n  void 0 === b && (b = []);\n  void 0 === c && (c = \"\");\n  void 0 === d && (d = []);\n  void 0 === e && (e = []);\n  a.forEach(function (a, g) {\n    var f = N([c, a.path]),\n        n = d.concat(a);\n    g = e.concat(g);\n    a.children && Q(a.children, b, f, n, g);\n    b.push([f, n, g]);\n  });\n  return b;\n}\n\nfunction R(a) {\n  var b = a.reduce(function (a, b) {\n    b = b[0];\n    a[b] = T(b);\n    return a;\n  }, {});\n  U(a, function (a, d) {\n    var c = a[2];\n    a = b[a[0]];\n    var f = d[2];\n    d = b[d[0]];\n    return a !== d ? d - a : V(c, f);\n  });\n}\n\nvar W = /^:\\w+$/,\n    X = 2,\n    Y = 1,\n    aa = 10,\n    ba = -2;\n\nfunction Z(a) {\n  return \"*\" === a;\n}\n\nfunction T(a) {\n  a = a.split(\"/\");\n  var b = a.length;\n  a.some(Z) && (b += ba);\n  return a.filter(function (a) {\n    return !Z(a);\n  }).reduce(function (a, b) {\n    return a + (W.test(b) ? X : \"\" === b ? Y : aa);\n  }, b);\n}\n\nfunction V(a, b) {\n  return a.length === b.length && a.slice(0, -1).every(function (a, d) {\n    return a === b[d];\n  }) ? a[a.length - 1] - b[b.length - 1] : 0;\n}\n\nfunction U(a, b) {\n  var c = a.slice(0);\n  a.sort(function (a, e) {\n    return b(a, e) || c.indexOf(a) - c.indexOf(e);\n  });\n}\n\nfunction S(a, b) {\n  \"string\" === typeof a && (a = {\n    path: a\n  });\n  var c = a;\n  a = c.path;\n  var d = c.caseSensitive;\n  c = c.end;\n  c = ca(a, void 0 === d ? !1 : d, void 0 === c ? !0 : c);\n  d = c[1];\n  c = b.match(c[0]);\n  if (!c) return null;\n  b = c[1];\n  var e = c.slice(2);\n  d = d.reduce(function (a, b, c) {\n    c = e[c];\n\n    try {\n      var d = decodeURIComponent(c.replace(/\\+/g, \" \"));\n    } catch (r) {\n      \"production\" !== process.env.NODE_ENV ? m(!1, 'The value for the URL param \"' + b + '\" will not be decoded because the string \"' + (c + '\" is a malformed URL segment. This is probably due to a bad percent encoding (') + (r + \").\")) : void 0, d = c;\n    }\n\n    a[b] = d;\n    return a;\n  }, {});\n  return {\n    path: a,\n    pathname: b,\n    params: d\n  };\n}\n\nfunction ca(a, b, c) {\n  var d = [],\n      e = \"^(\" + a.replace(/^\\/*/, \"/\").replace(/\\/?\\*?$/, \"\").replace(/[\\\\.*+^$?{}|()[\\]]/g, \"\\\\$&\").replace(/:(\\w+)/g, function (a, b) {\n    d.push(b);\n    return \"([^\\\\/]+)\";\n  }) + \")\";\n  a.endsWith(\"*\") ? (a.endsWith(\"/*\") && (e += \"\\\\/?\"), d.push(\"*\"), e += \"(.*)\") : c && (e += \"\\\\/?\");\n  c && (e += \"$\");\n  return [new RegExp(e, b ? void 0 : \"i\"), d];\n}\n\nfunction J(a, b) {\n  void 0 === b && (b = \"/\");\n  var c = \"string\" === typeof a ? parsePath(a) : a;\n  a = c.pathname;\n  var d = c.search;\n  d = void 0 === d ? \"\" : d;\n  c = c.hash;\n  c = void 0 === c ? \"\" : c;\n  return {\n    pathname: a ? da(a, a.startsWith(\"/\") ? \"/\" : b) : b,\n    search: d,\n    hash: c\n  };\n}\n\nfunction N(a) {\n  return a.join(\"/\").replace(/\\/\\/+/g, \"/\");\n}\n\nfunction da(a, b) {\n  var c = b.replace(/\\/+$/, \"\").replace(/\\/\\/+/g, \"/\").split(\"/\");\n  a.replace(/\\/\\/+/g, \"/\").split(\"/\").forEach(function (a) {\n    \"..\" === a ? 1 < c.length && c.pop() : \".\" !== a && c.push(a);\n  });\n  return 1 < c.length ? N(c) : \"/\";\n}\n\nfunction generatePath(a, b) {\n  void 0 === b && (b = {});\n  return a.replace(/:(\\w+)/g, function (a, d) {\n    return b[d] || \":\" + d;\n  }).replace(/\\*$/, function (a) {\n    return b[a] || a;\n  });\n}\n\n;\n\nfunction useBlocker(a, b) {\n  void 0 === b && (b = !0);\n  y() ? void 0 : \"production\" !== process.env.NODE_ENV ? l(!1, \"useBlocker() may be used only in the context of a <Router> component.\") : l(!1);\n  var c = useContext(p).history;\n  useEffect(function () {\n    if (b) {\n      var d = c.block(function (b) {\n        var c = h({}, b, {\n          retry: function () {\n            d();\n            b.retry();\n          }\n        });\n        a(c);\n      });\n      return d;\n    }\n  }, [c, b, a]);\n}\n\n;\n\nfunction useHref(a) {\n  y() ? void 0 : \"production\" !== process.env.NODE_ENV ? l(!1, \"useHref() may be used only in the context of a <Router> component.\") : l(!1);\n  var b = useContext(p).history;\n  a = K(a);\n  return b.createHref(a);\n}\n\n;\n\nfunction useLocationPending() {\n  return useContext(p).pending;\n}\n\n;\n\nfunction useMatch(a) {\n  y() ? void 0 : \"production\" !== process.env.NODE_ENV ? l(!1, \"useMatch() may be used only in the context of a <Router> component.\") : l(!1);\n  var b = I();\n  return S(a, b.pathname);\n}\n\n;\n\nfunction useParams() {\n  return useContext(q).params;\n}\n\n;\n\nfunction useRoutes(a, b) {\n  void 0 === b && (b = \"\");\n  y() ? void 0 : \"production\" !== process.env.NODE_ENV ? l(!1, \"useRoutes() may be used only in the context of a <Router> component.\") : l(!1);\n  var c = useMemo(function () {\n    return P(a);\n  }, [a]);\n  return H(c, b);\n}\n\n;\nexport { t as MemoryRouter, w as Navigate, A as Outlet, C as Route, v as Router, F as Routes, P as createRoutesFromArray, G as createRoutesFromChildren, generatePath, S as matchPath, O as matchRoutes, J as resolveLocation, useBlocker, useHref, y as useInRouterContext, I as useLocation, useLocationPending, useMatch, z as useNavigate, B as useOutlet, useParams, K as useResolvedLocation, useRoutes };","map":{"version":3,"sources":[],"names":[],"mappings":"","sourcesContent":["import{createMemoryHistory,parsePath}from'history';import PropTypes from'prop-types';import{createContext,useRef,createElement,useContext,useEffect,useState,useMemo,useCallback,Children,isValidElement,Fragment,useTransition as useTransition$1}from'react';function h(){h=Object.assign||function(a){for(var b=1;b<arguments.length;b++){var c=arguments[b],d;for(d in c)Object.prototype.hasOwnProperty.call(c,d)&&(a[d]=c[d])}return a};return h.apply(this,arguments)}var k=\"production\"!==process.env.NODE_ENV?function(a){return Object.freeze(a)}:function(a){return a};function l(a,b){if(!a)throw Error(b);}function m(a,b){if(!a){\"undefined\"!==typeof console&&console.warn(b);try{throw Error(b);}catch(c){}}}\nvar p=createContext({history:null,location:null,pending:!1,static:!1});\"production\"!==process.env.NODE_ENV&&(p.displayName=\"Location\");var q=createContext({outlet:null,params:k({}),pathname:\"\",route:null});\"production\"!==process.env.NODE_ENV&&(q.displayName=\"Route\");\nfunction t(a){var b=a.children,c=a.initialEntries,d=a.initialIndex;a=a.timeout;var e=useRef(null);null==e.current&&(e.current=createMemoryHistory({initialEntries:c,initialIndex:d}));return createElement(v,{children:b,history:e.current,timeout:a})}\n\"production\"!==process.env.NODE_ENV&&(t.displayName=\"MemoryRouter\",t.propTypes={children:PropTypes.node,timeout:PropTypes.number,initialEntries:PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string,PropTypes.shape({pathname:PropTypes.string,search:PropTypes.string,hash:PropTypes.string,state:PropTypes.object,key:PropTypes.string})])),initialIndex:PropTypes.number});\nfunction w(a){var b=a.to,c=a.replace,d=a.state;y()?void 0:\"production\"!==process.env.NODE_ENV?l(!1,\"<Navigate> may be used only in the context of a <Router> component.\"):l(!1);a=useContext(p);\"production\"!==process.env.NODE_ENV?m(!a.static,\"<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.\"):void 0;var e=z();useEffect(function(){e(b,{replace:c,\nstate:d})});return null}\"production\"!==process.env.NODE_ENV&&(w.displayName=\"Navigate\",w.propTypes={to:PropTypes.oneOfType([PropTypes.string,PropTypes.shape({pathname:PropTypes.string,search:PropTypes.string,hash:PropTypes.string})]).isRequired,replace:PropTypes.bool,state:PropTypes.object});function A(){return B()}\"production\"!==process.env.NODE_ENV&&(A.displayName=\"Outlet\",A.propTypes={});function C(a){a=a.element;return void 0===a?createElement(A,null):a}\n\"production\"!==process.env.NODE_ENV&&(C.displayName=\"Route\",C.propTypes={children:PropTypes.node,element:PropTypes.element,path:PropTypes.string});function D(a){return a()}var E=useTransition$1||function(){return[D,!1]};\nfunction v(a){var b=a.children;b=void 0===b?null:b;var c=a.history,d=a.static;d=void 0===d?!1:d;a=a.timeout;var e=void 0===a?2E3:a;y()?\"production\"!==process.env.NODE_ENV?l(!1,\"You cannot render a <Router> inside another <Router>. You never need more than one.\"):l(!1):void 0;var f=useState(c.location);a=f[0];var g=f[1];e=E({timeoutMs:e});var x=e[0];e=e[1];f=useRef(!d);f.current&&(f.current=!1,c.listen(function(a){var c=a.location;x(function(){g(c)})}));return createElement(p.Provider,{children:b,\nvalue:{history:c,location:a,pending:e,static:d}})}\"production\"!==process.env.NODE_ENV&&(v.displayName=\"Router\",v.propTypes={children:PropTypes.node,history:PropTypes.shape({action:PropTypes.string,location:PropTypes.object,push:PropTypes.func,replace:PropTypes.func,go:PropTypes.func,listen:PropTypes.func,block:PropTypes.func}),timeout:PropTypes.number});function F(a){var b=a.basename;b=void 0===b?\"\":b;a=G(a.children);return H(a,b)}\n\"production\"!==process.env.NODE_ENV&&(F.displayName=\"Routes\",F.propTypes={basename:PropTypes.string,caseSensitive:PropTypes.bool,children:PropTypes.node});function y(){return null!=useContext(p).location}function I(){y()?void 0:\"production\"!==process.env.NODE_ENV?l(!1,\"useLocation() may be used only in the context of a <Router> component.\"):l(!1);return useContext(p).location}\nfunction z(){y()?void 0:\"production\"!==process.env.NODE_ENV?l(!1,\"useNavigate() may be used only in the context of a <Router> component.\"):l(!1);var a=useContext(p),b=a.history,c=a.pending,d=useContext(q).pathname,e=useRef(!1);useEffect(function(){e.current=!0});return useCallback(function(a,g){void 0===g&&(g={});e.current?\"number\"===typeof a?b.go(a):(a=J(a,d),(g.replace||c?b.replace:b.push)(a,g.state)):\"production\"!==process.env.NODE_ENV?m(!1,\"You should call navigate() in a useEffect, not when your component is first rendered.\"):\nvoid 0},[b,d,c])}function B(){return useContext(q).outlet}function K(a){var b=useContext(q).pathname;return useMemo(function(){return J(a,b)},[a,b])}var L={};function M(a,b,c){b||L[a]||(L[a]=!0,\"production\"!==process.env.NODE_ENV?m(!1,c):void 0)}\nfunction H(a,b){void 0===b&&(b=\"\");var c=useContext(q),d=c.route,e=c.pathname,f=c.params;\"production\"!==process.env.NODE_ENV&&(c=d&&d.path,M(e,!d||d.path.endsWith(\"*\"),'You rendered descendant <Routes> (or called `useRoutes`) at \"'+e+'\" (under <Route path=\"'+(c+'\">) but the parent route path has no trailing \"*\". This means if you navigate deeper, the parent won\\'t match anymore and therefore the child routes will never render.\\n\\nPlease change the parent <Route path=\"')+(c+'\"> to <Route path=\"'+c+\n'/*\">.')));b=b?N([e,b]):e;var g=I();return(d=useMemo(function(){return O(a,g,b)},[g,a,b]))?d.reduceRight(function(a,c){var d=c.pathname,e=c.route;return createElement(q.Provider,{children:e.element,value:{outlet:a,params:k(h({},f,{},c.params)),pathname:N([b,d]),route:e}})},null):null}function P(a){return a.map(function(a){var c={caseSensitive:!0===a.caseSensitive,element:a.element||createElement(A,null),path:a.path||\"/\"};a.children&&(c.children=P(a.children));return c})}\nfunction G(a){var b=[];Children.forEach(a,function(a){if(isValidElement(a))if(a.type===Fragment)b.push.apply(b,G(a.props.children));else{var c={caseSensitive:!0===a.props.caseSensitive,element:a,path:a.props.path||\"/\"};a.props.children&&(a=G(a.props.children),a.length&&(c.children=a));b.push(c)}});return b}\nfunction O(a,b,c){void 0===c&&(c=\"\");\"string\"===typeof b&&(b=parsePath(b));b=b.pathname||\"/\";if(c)if(c=c.replace(/^\\/*/,\"/\").replace(/\\/+$/,\"\"),b.startsWith(c))b=b===c?\"/\":b.slice(c.length);else return null;a=Q(a);R(a);var d=null;for(c=0;null==d&&c<a.length;++c)a:{d=b;for(var e=a[c][1],f=\"/\",g={},x=[],n=0;n<e.length;++n){var r=e[n],u=\"/\"===f?d:d.slice(f.length)||\"/\";u=S({path:r.path,caseSensitive:r.caseSensitive,end:n===e.length-1},u);if(!u){d=null;break a}f=N([f,u.pathname]);g=h({},g,{},u.params);\nx.push({route:r,pathname:f,params:k(g)})}d=x}return d}function Q(a,b,c,d,e){void 0===b&&(b=[]);void 0===c&&(c=\"\");void 0===d&&(d=[]);void 0===e&&(e=[]);a.forEach(function(a,g){var f=N([c,a.path]),n=d.concat(a);g=e.concat(g);a.children&&Q(a.children,b,f,n,g);b.push([f,n,g])});return b}function R(a){var b=a.reduce(function(a,b){b=b[0];a[b]=T(b);return a},{});U(a,function(a,d){var c=a[2];a=b[a[0]];var f=d[2];d=b[d[0]];return a!==d?d-a:V(c,f)})}var W=/^:\\w+$/,X=2,Y=1,aa=10,ba=-2;\nfunction Z(a){return\"*\"===a}function T(a){a=a.split(\"/\");var b=a.length;a.some(Z)&&(b+=ba);return a.filter(function(a){return!Z(a)}).reduce(function(a,b){return a+(W.test(b)?X:\"\"===b?Y:aa)},b)}function V(a,b){return a.length===b.length&&a.slice(0,-1).every(function(a,d){return a===b[d]})?a[a.length-1]-b[b.length-1]:0}function U(a,b){var c=a.slice(0);a.sort(function(a,e){return b(a,e)||c.indexOf(a)-c.indexOf(e)})}\nfunction S(a,b){\"string\"===typeof a&&(a={path:a});var c=a;a=c.path;var d=c.caseSensitive;c=c.end;c=ca(a,void 0===d?!1:d,void 0===c?!0:c);d=c[1];c=b.match(c[0]);if(!c)return null;b=c[1];var e=c.slice(2);d=d.reduce(function(a,b,c){c=e[c];try{var d=decodeURIComponent(c.replace(/\\+/g,\" \"))}catch(r){\"production\"!==process.env.NODE_ENV?m(!1,'The value for the URL param \"'+b+'\" will not be decoded because the string \"'+(c+'\" is a malformed URL segment. This is probably due to a bad percent encoding (')+\n(r+\").\")):void 0,d=c}a[b]=d;return a},{});return{path:a,pathname:b,params:d}}function ca(a,b,c){var d=[],e=\"^(\"+a.replace(/^\\/*/,\"/\").replace(/\\/?\\*?$/,\"\").replace(/[\\\\.*+^$?{}|()[\\]]/g,\"\\\\$&\").replace(/:(\\w+)/g,function(a,b){d.push(b);return\"([^\\\\/]+)\"})+\")\";a.endsWith(\"*\")?(a.endsWith(\"/*\")&&(e+=\"\\\\/?\"),d.push(\"*\"),e+=\"(.*)\"):c&&(e+=\"\\\\/?\");c&&(e+=\"$\");return[new RegExp(e,b?void 0:\"i\"),d]}\nfunction J(a,b){void 0===b&&(b=\"/\");var c=\"string\"===typeof a?parsePath(a):a;a=c.pathname;var d=c.search;d=void 0===d?\"\":d;c=c.hash;c=void 0===c?\"\":c;return{pathname:a?da(a,a.startsWith(\"/\")?\"/\":b):b,search:d,hash:c}}function N(a){return a.join(\"/\").replace(/\\/\\/+/g,\"/\")}function da(a,b){var c=b.replace(/\\/+$/,\"\").replace(/\\/\\/+/g,\"/\").split(\"/\");a.replace(/\\/\\/+/g,\"/\").split(\"/\").forEach(function(a){\"..\"===a?1<c.length&&c.pop():\".\"!==a&&c.push(a)});return 1<c.length?N(c):\"/\"}\nfunction generatePath(a,b){void 0===b&&(b={});return a.replace(/:(\\w+)/g,function(a,d){return b[d]||\":\"+d}).replace(/\\*$/,function(a){return b[a]||a})};\nfunction useBlocker(a,b){void 0===b&&(b=!0);y()?void 0:\"production\"!==process.env.NODE_ENV?l(!1,\"useBlocker() may be used only in the context of a <Router> component.\"):l(!1);var c=useContext(p).history;useEffect(function(){if(b){var d=c.block(function(b){var c=h({},b,{retry:function(){d();b.retry()}});a(c)});return d}},[c,b,a])};\nfunction useHref(a){y()?void 0:\"production\"!==process.env.NODE_ENV?l(!1,\"useHref() may be used only in the context of a <Router> component.\"):l(!1);var b=useContext(p).history;a=K(a);return b.createHref(a)};function useLocationPending(){return useContext(p).pending};\nfunction useMatch(a){y()?void 0:\"production\"!==process.env.NODE_ENV?l(!1,\"useMatch() may be used only in the context of a <Router> component.\"):l(!1);var b=I();return S(a,b.pathname)};function useParams(){return useContext(q).params};\nfunction useRoutes(a,b){void 0===b&&(b=\"\");y()?void 0:\"production\"!==process.env.NODE_ENV?l(!1,\"useRoutes() may be used only in the context of a <Router> component.\"):l(!1);var c=useMemo(function(){return P(a)},[a]);return H(c,b)};export{t as MemoryRouter,w as Navigate,A as Outlet,C as Route,v as Router,F as Routes,P as createRoutesFromArray,G as createRoutesFromChildren,generatePath,S as matchPath,O as matchRoutes,J as resolveLocation,useBlocker,useHref,y as useInRouterContext,I as useLocation,useLocationPending,useMatch,z as useNavigate,B as useOutlet,useParams,K as useResolvedLocation,useRoutes}\n//# sourceMappingURL=index.js.map\n"]},"metadata":{},"sourceType":"module"}